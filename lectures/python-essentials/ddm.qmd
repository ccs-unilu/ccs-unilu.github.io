---
title: <i class="bi bi-patch-question"></i> Example Project
subtitle: Drift–Diffusion Model of Decision Making
date: 2025-11-21
date-format: "MMMM DD, YYYY"
published-title: "Date"
order: 3
sidebar: main
---

## Context

Many cognitive experiments present participants with simple choices (left or right, yes or no, same or different). These decisions produce two key behavioral measures:

- Accuracy (correct / incorrect)
- Response time (how long it took to respond)

However, raw behavioral data alone cannot explain why decisions were fast, slow, easy, or difficult. We need an explanatory model that links latent cognitive processes to the behavior we observe.

The Drift–Diffusion Model (DDM) describes decision making as a process of accumulating noisy evidence over time until a boundary is reached (to make a choice). The DDM has several key parameters that capture different aspects of the decision process:

![](./figures/ddm.jpg){fig-align="center" width="75%"}


- **v**: drift rate (speed and quality of evidence, task difficulty, stimulus strength)
- **a**: boundary separation (response caution, speed–accuracy tradeoff)
- **t0**: non-decision time (perceptual encoding, motor delay)
- **s**: diffusion constant (noise level, trial-to-trial variability)

By simulating this dynamic process, the DDM can recreate the patterns seen in real behavior:

- Distributions of fast vs. slow, correct vs. error
- Accuracy differences across conditions
- Individual differences in decision strategies

## Data

On each trial, participants saw a noisy patch tilted slightly left/right and had to decide its direction as quickly and accurately as possible. Stimulus was presented with two difficulty levels:
- easy: clear stimulus
- hard: noisy stimulus

The dataset is stored in the `2afc_clean.csv` file. Each row represents a single trial and contains:
- `agent_id`: unique identifier for each participant
- `trial_index`: incremental trial order for that participant
- `stimulus_description`: experimental condition ("easy" or "hard")
- `response_time`: time taken to respond (in seconds)
- `accuracy`: 1 = correct, 0 = incorrect

You can also find metadata about the experiment in `2afc_clean.yaml` in [CSVW format](https://csvw.org).

## TODO

Now, it's your turn to explore the data and simulate the DDM!

### Load and clean the data

- Load the CSV file into a pandas DataFrame using read_csv().
- Make sure the following columns exist: agent_id, trial_index, stimulus_description, response_time, accuracy.
- Drop rows with missing or impossible values (e.g., negative RT, RT > 10 s).
- Calculate the number of removed rows.
- Keep only response times between 0.2 and 3.0 seconds.


### Explore the data

- for each subject and condition (i.e., `stimulus_description`):
  - Compute mean RT for trials with correct responses.
  - Compute accuracy (proportion of correct trials).
  - Compute mean/sd response time.
  - Plot accuracy, RT distribution per condition using seaborn.barplot, histplot, or distplot.
  - Plot accuracy differences between conditions
  - Compute d-prime (using hit rate and false alarm rate). You can use `scipy.stats.norm.ppf(hit_rate) - scipy.stats.norm.ppf(fa_rate)` but be careful with extreme values (0 or 1).

  - Bin response times into:
    - fast (RT < 0.5s)
    - medium (0.5–1.0s)
    - slow (>1.0s)
  - Compute accuracy separately in each bin. What pattern do you observe?

### Simulate DDM

- Define a function: `simulate_ddm(v, a, t0, s, n_trials)`, which takes as input:
    - v: drift rate (speed and quality of evidence)
    - a: boundary separation (caution/threshold)
    - t0: non-decision time (perceptual encoding, motor delay)
    - s: diffusion constant (noise level, randomness)

- returns simulated response times and responses (1 or 0)

You can use a simple random-walk approximation:

```python
    import numpy as np
    def simulate_ddm(v, a, t0, s, n_trials=500):
        rts = []
        choices = []
        dt = 0.01  # time step
        for _ in range(n_trials):
            x = 0  # starting point
            time = 0
            while True:
                dx = v * dt + s * np.sqrt(dt) * np.random.randn()
                x += dx
                time += dt
                if x >= a:
                    rts.append(time + t0)
                    choices.append(1)  # upper boundary
                    break
                elif x <= 0:
                    rts.append(time + t0)
                    choices.append(0)  # lower boundary
                    break
        return np.array(rts), np.array(choices)
```

- Simulate easy condition (high drift)
- Simulate hard condition (low drift)
- Simulate a caution decision maker. Low caution: a = 0.7; Medium caution: a = 1.0; High caution: a = 1.6. Keep drift constant (v = 1.0).
    - How does accuracy change?
    - How does response time change?
    - Which one is more sensitive: accuracy or RT?

- Explore the effect of noise (s). How does noise change RT/accuracy?
- How does non-decision time (t0) affect RT distribution?

### Read data and compare to simulations

Now back to the real data:

For each condition in the real dataset:
- Compute empirical accuracy
- Compute empirical median response time
- Pick a drift rate that looks plausibly similar
- Simulate a DDM with that drift

This is not parameter fitting yet, just intuition building.

### Individual differences

Pick one participant, and for that participant:
- Compute accuracy in easy and hard conditions
- Which parameter (drift vs boundary vs noise) is likely to be different across conditions?
    - How drift changes behavior
    - How boundary changes behavior
    - How noise changes behavior
    - Why non-decision time is essential
- What mismatch you observed between real and simulated data?

### Grid search
- Try drift values between 0.1 and 2.0 and find the one that best matches empirical accuracy.
- Find which boundary value makes simulated RT median most similar to observed RT median.
- Plot several random drift–diffusion paths for intuition.


## PyDDM

You can also explore more complex DDMs using the [PyDDM](https://pyddm.readthedocs.io/en/latest/) package.

First install PyDDM if you haven't already (use `!pip` magic in Colab), and then run this code from the PyDDM website to create an interactive DDM explorer:

```python
import pyddm
import pyddm.plot
import numpy as np
model = pyddm.gddm(drift=lambda x,leak,driftrate : driftrate - x*leak,
                   noise=1,
                   bound=lambda t,initial_B,collapse_rate : initial_B * np.exp(-collapse_rate*t),
                   starting_position="x0",
                   parameters={"leak": (0, 2),
                               "driftrate": (-3, 3),
                               "initial_B": (.5, 1.5),
                               "collapse_rate": (0, 10),
                               "x0": (-.9, .9)})
            
pyddm.plot.model_gui_jupyter(model)
```

### Further reading

- [Ratcliff & McKoon (2008). The Diffusion Decision Model: Theory and Data for Two-Choice Decision Tasks. Neural Computation.](https://doi.org/10.1162/neco.2008.12-06-420)

- [PyDDM documentation](https://pyddm.readthedocs.io/en/latest/)